## TypeScript에 대한 이해

- 타입스크립트 동작 원리 (컴파일 과정 등에 대한 이해)
- 각 타입에 대한 역할
- 유틸리티 타입

<aside>
💡 타입스크립트는 자바스크립트의 슈퍼셋입니다 그 의미는 자바스크립트의 기능과 타입의 기능을 함께 가졌기 때문에 자바스크립트의 상위 집합이라고 볼 수 있습니다. 장점으로는 우선 타입스크립트는 정적으로 타입을 지정하기 때문에 런타임에서 타입에러를 체크하는 자바스크립트와 달리 개발 환경에서 타입 관련 에서를 잡아낼 수 있어서 개발 생상성이 향상된다는 장점이 있습니다. 그리고 협업을 할 때에도 동료 개발자가 해당 코드의 이해를 하기 편하고 타입을 이해한다거나, 객체의 프로퍼티의 정보를 이해하기에 용이합니다
</aside>

<br />

타입스크립트는 자바스크립트의 슈퍼셋이다. 자바스크립트의 기능과 타입 기능을 가졌기 때문에 자바스크립트의 상위라고 볼 수 있다

<br />

장점

1. 컴파일 언어이기 때문에 타입에 관련한 에러를 IDE에서 잡아낼 수 있어서 개발 생산성이 향상된다
2. 자바스크립트는 런타임에 동적으로 타입을 체크하기 때문에 실행 속도가 느리다 이에 반해 타입스크립트는 동적으로 개발자가 타입을 체크해놓기 때문에 실행 속도가 빠르다
3. 협업에 용이하다 동료 개발자가 해당 코드의 타입을 이해하거나 객체의 프로퍼티 등을 파악하기 편하다

<br />

## 타입스크립트 특징

자바스크립트는 동적 타입의 언어 (inpretter language)이므로 런타임에서 오류를 발견할 수 있다. 이에 반해 타입스크립트는 `정적 타입`의 `컴파일 언어`이기 떄문에 `컴파일러` , 바벨을 통해 자바스크립트 언어로 변환된다.

`코드 작성 단계`에서 타입을 체크해 오류를 확인 할 수 있고, 미리 타입을 결정하기 때문에 실행 속도가 매우 빠르다.

<br />

## any vs unknown

<aside>
💡 unknown은 모든 타입의 최상위 집합이지만 any는 집합에는 포함되지 않습니다. 타입 추론이 어려운 경우에는 any를 사용하는 것 보다는 unknown을 사용하고 타입가드를 이용하면 타입 추론을 할 수 있지만 any는 타입가드가 되지 않습니다.

</aside>

타입의 추론이 어려운 경우가 발생하면 any를 써서 해결하는 경우가 있다

→ 이 경우에는 `unknown` 타입을 사용하자

`unknown`과 `any`의 차이는 **타입이 집합에 포함되냐**로 구분할 수 있을것 같다.

`unknown`은 타입의 최상위 집합이지만 `any`는 타입의 집합에 포함되지 않는다.

<br />

### 결론

`unknown`을 사용하고 함수 내부에서 **타입 가드**를 이용하게 되면 타입가드가 되어서 특정 타입을 추론할 수 있지만 `any`를 이용할시 타입가드가 되지 않는 것을 확인할 수 있습니다.

<br />

## **Generics?**

<aside>
💡 제네릭은 함수나 클래스에 파라미터나 리턴값에 타입을 지정하지않고 타입을 처리할 수 있는 것입니다 제네릭을 사용하는 이유는 함수로 예를 들면 해당 함수의 재사용성을 높이고 확장성을 높일 수 있다는 것입니다.

</aside>

함수또는 클래스에서 파라미터와 리턴 값에 대한 타입을 기재하지 않고 다양한 타입을 처리 할 수 있는 것

제네릭을 통하여 함수 또는 클래스에 ‘틀’을 ‘주입’하여 그 `확장성`을 보다 높일 수 있습니다. 즉, 제네릭의 목적은 `재사용성(reusable)`을 높이고 함수나 클래스의 `확장성`을 높여 `중복된 코드를 방지`하기 위함이라고 할 수 있습니다.

```tsx
export async function fetchData(param: fetchDataParam): Promise<DataFormat> {
	//...
}

// 제네릭을 이용한 확장
async function fetchDataOf<T, U>(param: T): Promise<U> {
	const response = await fetch(`${param}`);
	return response.json();
}
```
