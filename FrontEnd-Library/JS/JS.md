---

## **자바스크립트의 원시 타입은 몇가지인가? 종류는?**

boolean, string, number, undefined , null , symbol 이렇게 6가지 종류

undefined는 선언만 되어있고 값은 없는 상태 , null은 자료형이 객체이며 빈값을 의미

---

## **실행 컨텍스트(Execution Context)란 ?**

자바스크립트의 코드들이 실행되기 위한 환경

전역 컨텍스트 ,함수 컨텍스트 2가지 존재

전역 컨텍스트 하나 생성 후에 함수 호출할 때마다 함수 컨텍스트가 생성되며 콜스택에 push

컨텍스트를 생성시에 변수객체, 스코프 체인, this가 생성된다.

컨텍스트 생성 후 함수가 실행되는데 사용되는 변수들은 변수 객체 안에서 값을 찾고 없다면 스코프체인을 따라 올라가며 찾음.

함수 실행이 마무리되면 해당 컨텍스트는 사라짐. 페이지가 종료되면 전역 컨텍스트가 사라짐

즉, 자바스크립트의 코드가 실행되기 위해서는 변수객체, 스코프체인, this 정보들을 담고 있는 곳을 실행컨텍스트라고 부른다.

실행 컨텍스트가 콜스택에 쌓이면 실행 컨텍스트가 활성화 되어 자바스크립트 엔진이 해당 컨텍스트에 관련된 코드들을 실행하는 데 필요한 **환경정보**를 수집해서 실행컨텍스트 객체에 저장

### 담기는 정보

- VariableEnvironment(변수 환경) : 현재 컨텍스트 내의 식별자 정보 + 환경정보가 담기며 최초 실행시의 스냅샷
- LexicalEnvironment(렉시컬 환경): 현재 컨텍스트 내의 식별자 정보 + 환경정보
- ThisBinding : This 식별자가 바라봐야할 대상 객체

변수 환경에 담기는 내용은 렉시컬 환경과 같지만 최초 실행시의 스냅샷을 유지한다는 점이 다르다.

실행컨텍스트를 생성할 때 변수환경에 먼저 담은 다음, 이를 그대로 복사해서 렉시컬 환경을 만들고 이후에는 렉시컬환경을 주로 활용.

변수환경과 렉시컬 환경 내부는 환경 레코드, 외부환경(스코프체인)으로 구성

🔍 함수가 호출되면 실행 컨텍스트가 생성되고 실행 컨텍스트 안에는 렉시컬 환경이 있음 !

---

## 렉시컬 환경 (Lexical Environment)

렉시컬 환경 : 스크립트 전체, 실행중인 함수, 코드블록 등은 자신만의 렉시컬 환경을 갖는다. 

각 렉시컬 환경은 총 3개의 컴포넌트를 갖는다.

1. 환경 레코드 (Environment Record)
2. 외부환경 참조 (Reference to the outer environment)
3. This 바인딩 (This Binding)

```
let a = 20;
const b = 30;
var c;

function multiply(e, f) {
 var g = 20;
 return e * f * g;
}

c = multiply(20, 30);
```

위의 렉시컬 환경 

```
GlobalExectionContext = {
LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      // Identifier bindings go here
      a: 20,
      b: 30,
      multiply: < func >
    }
    outer: <null>,
    ThisBinding: <Global Object>
  },
VariableEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      // Identifier bindings go here
      c: undefined,
    }
    outer: <null>,
    ThisBinding: <Global Object>
  }
}
```

함수 **multiply(20, 30)** 호출이 발생되면, 새로운 함수 실행 컨텍스트가 함수 코드를 실행하기 위해 생성된다.

```
FunctionExectionContext = {
LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      // Identifier bindings go here
      Arguments: {0: 20, 1: 30, length: 2},
    },
    outer: <GlobalLexicalEnvironment>,
    ThisBinding: <Global Object or undefined>,
  },
VariableEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      // Identifier bindings go here
      g: undefined
    },
    outer: <GlobalLexicalEnvironment>,
    ThisBinding: <Global Object or undefined>
  }
}
```

---

## **자바스크립트의 호이스팅(Hoisting)은 어떻게 이루어져 있는가**

변수를 선언하고 초기화 했을때 **선언**부분이 최상단으로 끌어올려지는 현상

예를들어, 코드 상단에서 console.log(a)를 찍고 하단에서 var a=1; 이라고 하였을때 a는 undefined라고 나온다. 이런 현상을 호이스팅이라고한다. 함수의 경우 함수표현식은 호이스팅이 적용되지 않으나 일반 함수선언문은 함수 호이스팅이 적용된다.

### 변수의 3 단계

**선언단계**

실행 컨텍스트에 변수를 등록하고 변수의 존재를 알림

**초기화단계**

변수에 값을 저장하기위한 메모리 공간을 확보하고 변수에 undefined를 할당해 초기화한다.

**할당단계**

실제 변수에 들어가는 값을 undefined와 교체하여 할당한다.

var는 선언단계와 초기화단계가 한꺼번에 일어난다 

그러므로 호이스팅에의해 할당하기 전에 변수에 접근하면 undefined를 출력

let,const는 스코프의 시작부터 초기화 이전 단계까지 TDZ(Temporal Dead Zone)의 영향을 받는다 

그러므로 초기화 이전에 변수에 접근하면 참조에러가 발생한다.

### 함수 호이스팅

함수 선언문으로 정의한 함수는 호이스팅되기 때문에 함수가 정의되기 전에 접근이 가능 

그러나 함수 표현식, 화살표 함수로 정의된 함수는 호이스팅이 되지만 

var 키워드로 함수를 정의한 경우에는 undefined를 가지고 있어 함수로 인식하지않고,

let,const 키워드로 함수를 정의한 경우에는 참조에러가 난다.

### **블록레벨 스코프**

var 키워드로 선언한 변수는 함수 레벨스코프이다. 

함수가 아닌 블록에서 변수를 선언한 경우에는 전역변수로 취급한다. 

es6부터 var의 결함을 해결하기위해 let,const를 도입했고 

let, const는 블록레벨 스코프로 이루어진다 

블록에서 선언된 변수는 블록 밖에서 접근할 수 없다. 

### **호이스팅 방지**

let,const는 호이스팅이 일어나지 않는다고 알고있지만 아니다.

let,const는 TDZ에 의해 영향을 받기 때문에 호이스팅이 일어나지만 

초기화 되기 이전에 호이스팅이 되기 때문에 참조 에러가 발생한다.

그러므로 호이스팅이 되지 않는 것처럼 인식된다 

---

## **클로저(Closure)란 무엇이며, 왜 이러한 패턴을 사용하는가**

내부함수가 외부함수의 컨텍스트에 접근할 수 있는 것을 가르킨다.

즉 외부함수에서 a라는 변수를 생성하고 외부함수 내부에서 정의된 내부함수에서 

a를 참조하게 된다면 외부함수가 종료되어도 내부함수는 외부함수의 컨텍스트에 접근 할 수 있다.

### 이유

자바스크립트 가비지컬렉터의 동작방식 때문

가비지 컬렉터는 참조하는 변수가 하나라d도 있으면 삭제 대상에 넣지 않는다

**자신이 생성될때의 환경을 기억하는 함수**

사용 하는 이유 :

1) 현재 상태를 기억하고 변경된 최신 상태를 유지하기 위해

2) 전역 변수의 사용을 억제 하기위해

3) 정보를 은닉하기 위해

---

## 자바스크립트 이벤트루프란 ?

자바스크립트 엔진은 ***Memory Heap*** 과 ***Call Stack*** 으로 구성되어 있다.

자바스크립트는 ***단일 스레드 (sigle thread) 프로그래밍*** 언어인데, 이 의미는 ***Call Stack이 하나*** 라는 이야기이다.

![스크린샷 2021-12-15 오후 3.55.12.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7e976178-4317-4d9c-a910-193853072166/스크린샷_2021-12-15_오후_3.55.12.png)

- Memory Heap : 메모리 할당이 일어나는 곳(ex, 우리가 프로그램에 선언한 변수, 함수 등이 담겨져 있음)
- Call Stack : 코드가 실행될 때 쌓이는 곳. stack 형태로 쌓임.
    - Stack(스택) : 자료구조 중 하나, 선입후출(LIFO, Last In First Out)의 룰을 따른다.

- ***Web API*** 는 ***브라우저에서 제공하는 API*** 로, DOM, Ajax, Timeout 등이 있다.Call Stack에서 실행된 비동기 함수는 Web API를 호출하고,Web API는 콜백함수를 Callback Queue에 밀어 넣는다.

- **Callback Queue란** ***비동기적으로 실행된 콜백함수가 보관*** 되는 영역이다. 예를 들어 setTimeout에서 타이머 완료 후 실행되는 함수(1st 인자), addEventListener에서 click 이벤트가 발생했을 때 실행되는 함수(2nd 인자) 등이 보관된다.

- **Event Loop**는 Call Stack과 Callback Queue의 상태를 체크하여, ***Call Stack이 빈 상태가 되면, Callback Queue의 첫번째 콜백을 Call Stack으로 밀어넣는다.***

정리 

- V8 엔진에서 코드가 실행되면, Call Stack에 쌓인다.
- Stack의 선입후출의 룰에 따라 제일 마지막에 들어온 함수가 먼저 실행되며,Stack에 쌓여진 함수가 모두 실행된다.
    - 비동기함수가 실행된다면, Web API가 호출된다.
    - Web API는 비동기함수의 콜백함수를 Callback Queue에 밀어넣는다.
    - Event Loop는 Call Stack이 빈 상태가 되면Callback Queue에 있는 첫번째 콜백을 Call Stack으로 이동시킨다.
    
    **자바스크립트를 단일 스레드 프로그래밍 언어라 한번에 하나씩 밖에 실행할 수 없다.그러나 Web API, Callback Queue, Event Loop 덕분에 멀티 스레드 처럼 보여진다.**
    

---

## This

- **자바스크립트에서 This는 몇가지로 추론 될수 있는가, 아는대로 말해달라**
- **일반함수의 this와 화살표 함수의 this는 어떻게 다른가?**자바스크립트의 내부함수는 일반 함수, 메소드, 콜백함수 어디에서 선언되었든지 this는 전역객체를 가르킴일반함수의 this는 window(전역)을 가르키며, 화살표 함수의 this는 언제나 상위스코프의 this를 가르킴
- **Call, Apply, Bind 함수에 대해 설명해달라**3가지 방법은 this를 바인딩하기 위한 방법이다.Call은 this를 바인딩하면서 함수를 호출하는 것, 두번째 인자를 apply와 다르게 하나씩 넘기는 것Apply는 this를 바인딩하면서 함수를 호출하는 것, 두번째인자가 배열 Bind는 함수를 호출하는 것이 아닌 this가 바인딩 된 새로운 함수를 리턴함.
- **use strict모드에서의 this?**일반함수에서의 this는 undefined가 바인딩 됨.

---

## 세션, 쿠키, 로컬 스토리지 비교

## 쿠키

쿠키는 서버가 사용자의 정보를 담은 데이터로, 다음과 같은 특징이 있다.

### 특징

- 클라이언트의 로컬 저장소, 쉽게 말해 내 컴퓨터에 저장된다.
- key - value의 쌍으로 구분되어 있다.
- 웹사이트에 대한 정보 및 개인정보가 같이 기록된다. (이는 웹 브라우저 자체에 거부 기능으로 설정 가능하지만, 서버와 연결 지속이 불가능하다.)
- 쿠키는 유효 시간이 있는데, 쿠키를 일부러 삭제하지 않는 이상 유효 시간동안에는 쿠키의 기능을 발휘한다.
- 브라우저마다 저장되는 쿠키가 다르다. 때문에, 크롬으로 로그인 후 edge로 동일 사이트를 접속해도 로그인은 크롬에만 되어있다.

### 동작

1. 클라이언트가 서버에 요청(Request)을 한다.
2. 서버는 요청을 받고, 응답(Response)을 한다. 이 때, Response-Header에 set-cookie 속성 사용 시, 클라이언트에 쿠키 생성과 저장이 가능하다.
3. 브라우저는 요청을 보낼 때, request-header에 저장된 쿠키를 자동으로 넣어 서버에 전송한다.

### 단점

쿠키는 다음과 같은 이유로 보안에 취약하다.

- 쿠키는 사용자, 내 컴퓨터에 저장된다. 따라서 임의로 수정이 가능하고, 파일을 직접 탈취할 수 있다.
- Request-Header에 쿠키 정보를 넣어 서버에 전송할 때, 스니핑(도청)으로 개인정보를 가로 채는 것이 가능하다.

## 세션

```
ex) 입력 폼 정보, 일회성 로그인, 비회원 장바구니
    보안 문제 있어서 비밀번호같은건 절대 저장X
```

쿠키의 보안 취약점을 보완하기 위해 세션이 등장했다.

### 특징

- 서버에서 생성 후, 서버에서 관리한다.
- 클라이언트 저장소에 저장되는 세션ID는 클라이언트마다 고유하게 부여된다. 따라서 로그아웃 후, 다시 로그인 할 경우에도 세션ID는 다르다.
- 쿠키에 세션 ID만 저장된다. 이는 중요한 개인 정보는 서버 저장소에 위치한다.
- 세션에도 유효 시간이 있지만, 유효 시간이 지나지 않아도 브라우저 종료 시 세션은 제거된다.
- 서버에 사용자 정보를 두기 때문에 쿠키보다 보안에 좋다.

### 동작

![스크린샷 2021-12-16 오후 10.59.04.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c5bfe1b2-0c94-48d5-a3f9-c8aa92945033/스크린샷_2021-12-16_오후_10.59.04.png)

1. 클라이언트가 서버에 요청(Request, n = 1)을 한다.
2. 서버는 요청을 받고, 사용자를 확인 후 회원 정보에 대한 세션을 저장소에 생성한다.
3. 클라이언트마다 고유한 세션ID을 발급하여 응답(Response)한다.
4. 사용자는 발급받은 세션 ID를 쿠키에 저장하고, 재요청(n ≥ 2) 시 쿠키를 보낸다.
5. 서버는 쿠키에 동봉된 세션 ID를 확인하여 인증을 완료한다.
- *이 때, 쿠키는 세션ID가 저장된 매개체이다.*

### 단점

- 많은 회원이 로그인 할 경우, 서버의 과부하가 발생한다.
- 여전히 스니핑(도청)으로 쿠키를 탈취하여 세션ID를 가로 채는 것이 가능하다.

## 로컬스토리지

`ex) 자동 로그인 저장`

클라이언트에 대한 정보를 영구적(강제로 지우지 않는 이상)으로 보관하는 것이 세션스토리지와 큰 차이점 이고 

그외에는 모두 동일함

**장점** : 서버에 불 필요하게 데이터 저장 안 하고 용량이 크다.

---

## 주소창에 [google.com](http://google.com)을 치면 일어나는일

1. 브라우저가 URL을 해석
2. 브라우저는 캐싱 된 DNS 기록을 통해 google.com에 대응되는 ip주소가 있는지 확인
3. 캐싱이 없다면 DNS에 해당 도메인의 IP주소를 요청
4. 해당하는 IP주소가 있다면 브라우저는 get요청을 통해 www.google.com의 웹페이지 요구
5. 서버가 http response를 보낸다
6. 브라우저가 HTML content를 보여준다

---

# Redux와 Context API의 차이 ✔️

위의 설명만 보면은 Redux와 Context API는 사실상 차이가 거의 없어보입니다. 둘 다 전역 상태 관리를 위한 도구라는 공통점을 가지고 있기 때문이죠. 사실 Redux 또한 Context API를 가지고 만든 라이브러리입니다. 전역 상태 관리 측면에서는 차이점이 거의 없다고 봐도 무방하다는 의미입니다. *(Context API는 high-frequency updates에 좋지 않은 성능을 보이지만 Redux는 그렇지 않습니다)*

하지만 Redux는 Context API와 다르게 전역 상태 관리외에 다양한 기능을 제공합니다.

![https://media.vlpt.us/images/cada/post/2fe54f52-a384-444a-88ad-05fd2d10028c/das.PNG](https://media.vlpt.us/images/cada/post/2fe54f52-a384-444a-88ad-05fd2d10028c/das.PNG)

Dan Abrarnov의 Medium 게시글을 발췌한 부분입니다.위 항목들은 모두 Redux가 Context API에 비해 가지는 강점입니다. `redux-saga`, `redux-thunk`, `redux-devtools` 등 다양한 추가 라이브러리를 통해 우리가 조금 더 상태 관리를 수월하게하고 긴밀하고 정확한 코딩을 할 수 있도록 합니다. 여러 라이브러리가 모여 Redux라는 하나의 프레임워크가 되어 개발자에게 큰 도움을 주고 있는 것으로 볼 수 있습니다. 하지만 Context API는 이런 부가적인 기능을 제공하지 않아 다른 라이브러리를 통해 구현해야합니다.

Redux가 많은 기능을 제공하지만 Context API에 비해 작성해야하는 코드도 많고 복잡하기 때문에 이런 부가 기능이 필요하지 않다면 Redux를 사용하지 않아도 됩니다.

---

## **화살표 함수와 함수 선언문의 차이**

우선 바인딩이란, 함수 호출과 실제 함수를 연결하는 방법이다.

함수를 호출하는 부분에서 실제 함수가 위치한 메모리를 연결하는 것도 바인딩이다.

바인딩은 정적 바인딩(static binding)과 동적 바인딩(dynamic binding)으로 구분할 수 있다.

정적 - 실행 시간 전에 일어남. 실행 시간에는 변하지 않는 상태로 유지.

동적 - 실행 시간에 이루어지거나 실행 시간에 변경됨.

### **함수 선언문의 this**

- 일반 함수의 선언에서는 this가 전역객체(window)를 가리킴
- 메소드에서는 this를 메소드를 소유하고있는 객체를 가리킴
- 생성자로 정의된 함수는 생성자로인해  새롭게 만들어진 객체를 가리킴

**함수가 어떻게 호출되었는지에 따라 this에 바인딩할 객체가 동적으로 결정**

### **화살표 함수의 this**

- 화살표 함수는 this가 상위 스코프를 가리킴

**화살표 함수**는 선언할 때 this에 바인딩할 객체가 정적으로 결정된다.

어떻게 선언되었는지에 따라 결정된다.

또한, call, apply, bind 메소드를 사용하여 this를 변경할 수 없다.

### **화살표함수는 생성자 함수로 사용 못 한다.**

**prototype 프로퍼티를 가지고 있지 않기 때문**이다.

### **arguments 사용 가능 불가능**

- 일반 함수에서는 함수가 실행될 때 암묵적으로 arguments 변수가 전달되어 사용 가능
- 화살표 함수에서는 arguments 변수가 전달되지 않는다.

```jsx
function fun() {
	console.log(arguments); // Arguments(3) [[1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]
}

fun(1, 2, 3);

const arrFun = () => {
	console.log(arguments); // Uncaught ReferenceError: arguments is not defined
};

fun(1, 2, 3);
```

this 정적 바인딩 - 런타임 이전에 결정됨 

this 동적 바인딩 - 런타임 이후에 결정됨 

차이 

함수 선언문은 this가 어떻게 호출되느냐에 따라 동적으로 결정됨

일반적으로 함수를 정의했을 경우에는 this가 전역 객체를 가리킴

메소드에서의 this는 메소드를 소유하고 있는 객체를 가리킴

생성자로 정의된 함수에서는 생성자로 인해 만들어진 객체를 가리킴

어떻게 호출되느냐에 따라 다름(동적바인딩)

화살표함수는 this를 상위 스코프만 가리킴 (정적 바인딩)

또 다른 차이점 

화살표 함수는 arguments변수가 없다 

기본적으로 함수 선언문으로 함수를 정의하면 암묵적으로 arguments 변수가 전달되어 사용가능 근데 화살표 함수는 없음.

화살표 함수는 생성자 함수로 사용 못한다. 

prototype 객체를 가지고 있지 않기때문에.

---

## **타입스크립트 자바스크립트 차이**

자바스크립트는 동적언어이므로 런타임에서 오류를 발견

타입스크립트는 정적언어 이면서 컴파일언어 컴파일러를 통해 자바스크립트로 변환되면 코드 작성 단계에서 오류를 발견할 수 있음

자바스크립트는 함수의 파라미터에 대해 타입 체킹을 안 해준다. 

```jsx
function test(arr) {
  arr. // 자동완성
 안 됨 ㅠㅠ
}
```

타입스크립트의 장점이 이것이다. 

타입체킹을 해주기 때문에 함수의 파라미터, 컴포넌트의 prop, 리덕스의 state등 

코드 작성 단계에서 체킹을 해주기 때문에 오류를 줄일 수 있고 일일이 파일을 열어서 필요한 데이터의 타입을 확인하지 않아도 된다. 

또 협업할 때에도 장점이 있는데 , 컴포넌트,함수등을 사용할때 어떤 타입의 값이 들어가는지 코드를 확인하거나, 주석을 달거나 하지 않아도 IDE에서 확인이 가능하다 !
